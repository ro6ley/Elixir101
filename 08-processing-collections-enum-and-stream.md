# Processing Collections - Enum and Stream

Elixir comes with a number of types that act as collections including: `lists`, `dictionaries`, `ranges`, `files` and even `functions`.

Things that can be iterated are said to implement the `Enumerable` protocol.

Elixir provides two modules with a bunch of iteration functions:
  - Enum module:
  - Stream module: this lets you enumerate a collection lazily i.e. the next
                   value is only calculated when needed.

## Enum - Processing Collections

It is used to `iterate`, `filter`, `combine`, `split` and `manipulate` collections.
Some common tasks include:
- Convert any collection into a list
  ```
  IO.inspect Enum.to_list 1..5 [1, 2, 3, 4, 5]
  ```
- Concatenate collections:
  ```
  IO.inspect Enum.concat [1,2,3], [4,5,6] [1, 2, 3, 4, 5, 6]
  ```
- Create collections whose elements are some function of the original:
  ```
  IO.inspect Enum.map([1,2,3,4,5], &(&1 * 10)) [10, 20, 30, 40, 50]
  ```
- Select elements by position or criteria:
  ```
  IO.puts Enum.at(10..20, 3)               #=> 13
  
  IO.puts Enum.at(10..20, 20)              #=> nil, no position 20 in the array

  IO.inspect Enum.filter(1..5, &(&1 > 2))  #=> [3, 4, 5]
  ```
- Sort and compare elements:
  ```
  IO.inspect Enum.sort ["a", "b", "d", "e", "c"]    #=>  ["a", "b", "c", "d", "e"]

  IO.inspect Enum.sort ["there", "was", "a", "crooked", "man"], &(String.length(&1) <= String.length(&2))

  IO.inspect Enum.max ["there", "was", "a", "crooked", "man"]  #=> "was"

  IO.inspect Enum.max_by ["there", "was", "a", "crooked", "man"], &String.length/1   #=> "crooked"
  ```
- Split a collection
  ```
  IO.inspect Enum.take(1..5, 3)                #=> [1,2,3]

  IO.inspect Enum.take_every 1..5, 2           #=> [1,3,5]

  IO.inspect Enum.take_while 1..5, &(&1 < 4)   #=> [1, 2, 3]

  IO.inspect Enum.split 1..5, 3                #=> {[1,2,3], [4,5]}

  IO.inspect Enum.split_while 1..5, &(&1 < 4)  #=> {[1,2,3], [4,5]}
  ```
- Join a collection:
  ```
  IO.puts Enum.join 1..5           #=> "12345"

  IO.puts Enum.join 1..5, "-"      #=> "1-2-3-4-5"
  ```
- Predicate operations:
  ```
  IO.puts Enum.all?(1..5, &(&1 < 4))  #=> false

  IO.puts Enum.any?(1..5, &(&1 < 4))  #=> true

  IO.puts Enum.member?(1..5, 4)       #=> true

  IO.puts Enum.empty?(1..5)           #=> false
  ```
- Merge colections:
  ```
  IO.inspect Enum.zip(1..5, [:a, :b, :c])   #=> [{1, :a}, {2, :b}, {3, :c}]
  ```
- Fold elements into a single value:
  ```
  IO.puts Enum.reduce(1..100, &(&1+&2))     #=> 5050
  ```

## Streams - Lazy Enumerables

Streams allow us to process elements in a collection as we need them. We don't need to store the intermediate results as full collections; we just need to pass the current element from function to function.

A stream is a composable enumerator.

Creating a stream:
```
s = Stream.map [1, 3, 5, 7], &(&1 + 1)   #=>  Stream<[enum: [1, 3, 5, 7], funs: [Function<48.58052446/1 in Stream.map/2>]]>
IO.inspect s
```

We don't get the inteded result, but we get a strem value that contains  specification of what we intended.

To make the stream start giving us results we treat it as a collection and pass it to a function in the Enum module.
```
IO.inspect Enum.to_list s [2, 4, 6, 8]
```

> You can also pass a stream to a stream.

With streams there is no intermediate storage but it runs about two times slower than Enum. With Enum we'd have to wait for all the lines to arrive before we started processing but with streams we can process them as they arrive.

### Infinite Streams

Because streams are lazy, there's no need for the whole collection to be available upfront. Example:
```
IO.inspect Enum.map(1..10_000_000, &(&1+1)) |> Enum.take(5) [2, 3, 4, 5, 6]
```

This will take a while since Elixir is creating a 10-million-element list then taking the first 5 elements. But when using streams:
```
IO.inspect Stream.map(1..10_000_000, &(&1+1)) |> Enum.take(5) [2, 3, 4, 5, 6]
```

The result comes back instantly since the call just needs five values, which it gets from the stream. Once it has them, there's no more need for processing.

There are some helpful wrapper functions to use with Streams including:
  `cycle`, `repeatedly`, `iterate`, `unfold` and `resource`.

#### Stream.cycle

This takes an enumerable and returns an infinite stream containing the enumerable's elements. When it gets to the end it repeats from the beginning.

#### Stream.repeatedly

It takes a function and invokes it each time a new value is wanted.

#### Stream.iterate

`Stream.iterate(start_value, next_fun)` generates an infinite stream. The first value is the `start_value`, the next value is generated by applying `next_fun` to this value. This continues for as long as the stream is being used.

#### Stream.unfold

It is related to `Stream.iterate` but you can be more explicit both about the values output to the stream and about the values passed to the next iteration.

#### Stream.resource

It enables us to execute a query when the stream starts, returns each row as stream values, and close the query at the end.

## The Collectable Protocol

Collectable is a protocol that allows you to build a collection by inserting elements into it.
Not all collections are collectables, `ranges`, for example, cannot have new entries added to them.

You can access the collectable API using `Enum.into` and when using comprehensions.
Eg, injecting elements of a range into an empty list:
```
IO.inspect Enum.into 1..5, []    #=>  [1, 2, 3, 4, 5]
```

If the list is not empty, the new elements are tacked into the end:
```
IO.inspect Enum.into 1..5, [100, 101]     #=> [100, 101, 1, 2, 3, 4, 5]
```
Output streams are collectable, so the following code lazily copies standard input to standard output:
```
Enum.into IO.stream(:stdio, :line), IO.stream(:stdio, :line)
```

## Comprehensions

This is a general purpose shortcut to map and filter collections. 

The idea of a comprehension is: 
`given one or more collections, extract all combinations of values from each,optionally filter the values, and then generate a new collection using the values that remain.`

Syntax:
```
  result = for generator or filter... [, into: value], do: expression

#=> Examples:

IO.inspect for x <- [1, 2, 3, 4, 5], do: x * x          #=>  [1, 4, 9, 16, 25]

IO.inspect for x <- [1, 2, 3, 4, 5], x < 4, do: x * x   #=>  [1, 4, 9]
```

A generator specifies how you want to extract values from a collection `pattern <- list`.

If we have two generators, their operations are nested, so:
```
  x <- [1, 2], y <- [5, 6]
  ### will run the rest of the comprehension with x=1, y=5; x=1, y=6; x=2, y=5; x=2, y=6;
```

We can use variables from generators in later generators:
```
min_maxes = [{1, 4}, {2, 3}, {10, 15}]

IO.inspect for {min, max} <- min_maxes, n <- min..max, do: n [1, 2, 3, 4, 2, 3, 10, 11, 12, 13, 14, 15]
```

A `filter` is a predicate - it acts as a gatekeeper for the rest of the comprehension - if the condition is false, then the comprehension moves to the next iteration without generating an output value.

Because the first term in a generator is a pattern, we can use it to deconstruct structured data.
```
reports = [dallas: :hot, minneapolis: :cold, dc: :muggy, la: :smoggy]

IO.inspect for {city, weather} <- reports, do: {weather, city}  #=> [hot: :dallas, cold: :minneapolis, muggy: :dc, smoggy: :la]
```

Comprehensions work on bits too.
```
IO.puts for << ch <- "hello" >>, do: ch 'hello'
```

## Scoping and comprehensions

All variable assignments inside a comprehension are local to that comprehension - _you will not affect the value of a variable in the outer scope_.

### The Value Returned by a Comprehension

An `into` parameter can be used to define the collection into which the results of the comprehension. Eg:
```
IO.inspect for x <- ~w{cat dog}, into: %{}, do: { x, String.upcase(x) }
```

The collection does not have to be empty.
```
IO.inspect for x <- ~w{ cat dog }, into: %{"ant" => "ANT"}, do: { x, String.upcase(x) }
```

The `into` option takes values that implement the `Collectable` protocol - including `lists`, `binaries`, `functions`, `maps`, `files`, `hash dicts`, `hash sets` and `IO streams`.
